
import os
import subprocess
import re
from pathlib import Path
import google.generativeai as genai
from urllib3 import ProxyManager, make_headers
from config import GEMINI_API_KEY, PROXY_URL, PROXY_LOGIN, Language

class Executor:
    '''
    Handles the execution of code generated by Gemini.
    '''

    def __init__(self, task: str, language: Language, save_path: str):
        '''
        Arguments:
        - task: The description of the program to be executed.
        - language: The programming language of the generated code.
        - save_path: The path where the generated code will be saved.
        '''

        self.task = task
        self.language = language
        self.save_path = Path(save_path)
        self.__code = None
        self.__dependencies = []

        
    @property
    def code(self):
        return self.__code

    def execute(self):
        # Get code from Gemini
        model = self._setup_gemini()
        prompt = f"{self.task}\n\nInclude required dependencies. The program should be written on {self.language.value}."
        
        print('sending request to Gemini...')
        response = model.generate_content(prompt).text
        print('response received')
        
        # Extract code and dependencies
        self._extract_code_and_dependecies(response)
        
        # Install dependencies
        self._install_dependencies()
        
        # Save code to file
        file_path = self._save_code()
        
        # Compile if needed
        executable_path = self._compile_code(file_path)
        
        # Run the code
        self._run_code(executable_path)
        
    def _setup_gemini(self):        
        genai.configure(api_key=GEMINI_API_KEY)
        model = genai.GenerativeModel('gemini-2.0-pro-exp-02-05')

        return model
        
    def _extract_code_and_dependecies(self, response: str) -> tuple:
        '''Extract code block between  markers'''

        code_pattern = r".*?\n(.*?)"
        code_match = re.search(code_pattern, response, re.DOTALL)

        if code_match:
            self.__code = code_match.group(1).strip()
        else:
            self.__code = response
            
        # Extract dependencies
        dep_pattern = r"(.*?)(?=|\Z)"
        dep_match = re.search(dep_pattern, response, re.DOTALL)

        if dep_match:
            deps = dep_match.group(1).strip().split('\n')
            self.__dependencies = [d.strip('- ') for d in deps if d.strip()]
            

    def _install_dependencies(self):
        for dep in self.__dependencies:
            try:
                if os.name == 'posix':
                    subprocess.run(dep, check=True)
            except subprocess.CalledProcessError as e:
                print(f"Failed to install {dep}: {e}")

    def _save_code(self):
        extension = {
            Language.PYTHON: '.py',
            Language.CPP: '.cpp',
            Language.C: '.c'
        }.get(self.language, '.txt')
        
        file_path = self.save_path / f"main{extension}"
        file_path.parent.mkdir(parents=True, exist_ok=True)
        
        with open(file_path, 'w') as f:
            f.write(self.code)

        return file_path

    def _compile_code(self, file_path: Path):
        if self.language == Language.CPP:
            output_path = file_path.with_suffix('.exe' if os.name == 'nt' else '')
            subprocess.run(['g++', str(file_path), '-o', str(output_path)], check=True)
            return output_path
        elif self.language == Language.JAVA:
            subprocess.run(['javac', str(file_path)], check=True)
            return file_path.with_suffix('.class')
        elif self.language == Language.CS:
            subprocess.run(['csc', str(file_path)], check=True)
            return file_path.with_suffix('.exe')
        
        return file_path
    
    def _run_code(self, file_path: Path):
        if self.language == Language.PYTHON:
            subprocess.run(['python', str(file_path)], check=True)
        elif self.language == Language.JAVASCRIPT:
            subprocess.run(['node', str(file_path)], check=True)
        elif self.language in [Language.CPP, Language.CS]:
            subprocess.run([str(file_path)], check=True)
        elif self.language.lower() == 'java':
            subprocess.run(['java', file_path.stem], check=True)
